<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Kono Draw</title>
<style>
  :root { --ui: #f5f5f7; --ink:#111; --line:#ddd; }
  html,body { height:100%; margin:0; }
  body { background:#fff; font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif; }
  .toolbar {
    position: fixed; top: 0; left: 0; right: 0;
    display:flex; gap:.5rem; align-items:center; padding:.5rem .75rem;
    background: var(--ui); border-bottom: 1px solid var(--line); z-index: 10;
  }
  .toolbar > * { height: 36px; }
  .spacer { flex:1; }
  .btn {
    padding:.4rem .7rem; border:1px solid var(--line); background:#fff; border-radius:10px; cursor:pointer;
  }
  .btn[disabled] { opacity:.45; cursor:not-allowed; }
  #canvas { position: fixed; top: 56px; /* toolbar height */ left:0; right:0; bottom:0; touch-action: none; display:block; }
  .group { display:flex; gap:.5rem; align-items:center; }
  .label { font-size:.85rem; color:#333; }
  input[type="range"] { width:140px; }
</style>
</head>
<body>
  <div class="toolbar" id="toolbar">
    <div class="group">
      <button class="btn" id="penBtn" title="Pen (P)">Pen</button>
      <button class="btn" id="eraserBtn" title="Eraser (E)">Eraser</button>
      <button class="btn" id="clearBtn" title="Clear">Clear</button>
    </div>
    <div class="group">
      <span class="label">Color</span>
      <input type="color" id="color" value="#000000">
    </div>
    <div class="group">
      <span class="label">Brush</span>
      <input type="range" id="size" min="1" max="48" value="8">
      <span id="sizeVal" class="label">8</span>
    </div>
    <div class="group">
      <button class="btn" id="undoBtn" title="Undo (âŒ˜/Ctrl+Z)">Undo</button>
      <button class="btn" id="redoBtn" title="Redo (âŒ˜/Ctrl+Shift+Z)">Redo</button>
    </div>
    <div class="spacer"></div>
    <div class="group">
      <button class="btn" id="saveBtn" title="Save PNG">Save PNG</button>
    </div>
  </div>

  <canvas id="canvas"></canvas>

<script>
(() => {
  // ðŸ†• Setup
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const dpr = () => Math.max(1, window.devicePixelRatio || 1);

  const colorEl = document.getElementById('color');
  const sizeEl  = document.getElementById('size');
  const sizeVal = document.getElementById('sizeVal');
  const penBtn = document.getElementById('penBtn');
  const eraserBtn = document.getElementById('eraserBtn');
  const clearBtn = document.getElementById('clearBtn');
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');
  const saveBtn = document.getElementById('saveBtn');

  let isDrawing = false;
  let lastX = 0, lastY = 0;
  let mode = 'pen'; // 'pen' | 'erase'
  let pressureEnabled = true;

  // ðŸ†• Undo/Redo stacks
  const UNDO_LIMIT = 30;
  const undoStack = [];
  const redoStack = [];
  function pushUndo() {
    try {
      if (undoStack.length >= UNDO_LIMIT) undoStack.shift();
      undoStack.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
      redoStack.length = 0;
      refreshUndoRedoButtons();
    } catch (e) {
      // If memory error on huge canvas, fall back to nothing
      console.warn('Undo snapshot failed', e);
    }
  }
  function refreshUndoRedoButtons(){
    undoBtn.disabled = undoStack.length === 0;
    redoBtn.disabled = redoStack.length === 0;
  }

  // ðŸ†• Canvas sizing with DPR & preserve content
  function resizeCanvas() {
    const toolbarH = document.getElementById('toolbar').offsetHeight || 56;
    const cssW = window.innerWidth;
    const cssH = Math.max(0, window.innerHeight - toolbarH);

    const ratio = dpr();
    const old = ctx.getImageData(0, 0, canvas.width || 1, canvas.height || 1);

    canvas.style.width = cssW + 'px';
    canvas.style.height = cssH + 'px';
    canvas.width = Math.floor(cssW * ratio);
    canvas.height = Math.floor(cssH * ratio);

    ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
    ctx.imageSmoothingEnabled = true;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    // Redraw previous content centered/top-left if sizes changed
    if (old.width && old.height) {
      // Put back scaled to new size
      // Create an offscreen to draw old at 1:1 then scale
      const off = document.createElement('canvas');
      off.width = old.width; off.height = old.height;
      off.getContext('2d').putImageData(old, 0, 0);
      ctx.save();
      ctx.setTransform(1,0,0,1,0,0); // work in CSS pixels
      ctx.drawImage(off, 0, 0, old.width / ratio, old.height / ratio);
      ctx.restore();
    } else {
      // white background (optional). Comment out for transparent.
      // ctx.fillStyle = '#fff'; ctx.fillRect(0,0,canvas.width,canvas.height);
    }
    refreshUndoRedoButtons();
  }
  window.addEventListener('resize', resizeCanvas, { passive: true });
  resizeCanvas();

  // ðŸ†• Drawing helpers
  function getPoint(e){
    const rect = canvas.getBoundingClientRect();
    let x, y;
    if (e.touches && e.touches[0]) {
      x = e.touches[0].clientX - rect.left;
      y = e.touches[0].clientY - rect.top;
    } else {
      x = e.clientX - rect.left;
      y = e.clientY - rect.top;
    }
    return { x, y };
  }

  function pointerDown(e){
    e.preventDefault();
    pushUndo();
    isDrawing = true;
    const { x, y } = getPoint(e);
    lastX = x; lastY = y;
    drawLine(x, y, x, y, e);
  }

  function pointerMove(e){
    if (!isDrawing) return;
    e.preventDefault();
    const { x, y } = getPoint(e);
    drawLine(lastX, lastY, x, y, e);
    lastX = x; lastY = y;
  }

  function pointerUp(e){
    if (!isDrawing) return;
    e.preventDefault();
    isDrawing = false;
  }

  function drawLine(x1, y1, x2, y2, e){
    const baseSize = Number(sizeEl.value);
    const p = (e.pressure && pressureEnabled) ? Math.max(0.1, e.pressure) : 1;
    const width = baseSize * p;

    ctx.save();
    ctx.globalCompositeOperation = mode === 'erase' ? 'destination-out' : 'source-over';
    if (mode === 'pen') ctx.strokeStyle = colorEl.value;

    ctx.lineWidth = width;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();
  }

  // ðŸ†• Pointer events (works for mouse/touch/Apple Pencil)
  // Prefer Pointer Events if available
  const supportsPointer = 'onpointerdown' in window;
  if (supportsPointer){
    canvas.addEventListener('pointerdown', pointerDown);
    canvas.addEventListener('pointermove', pointerMove);
    window.addEventListener('pointerup', pointerUp);
    // Allow only pen/mouse/touch drawing; prevent gestures scrolling
    canvas.style.touchAction = 'none';
  } else {
    // Fallback to mouse + touch
    canvas.addEventListener('mousedown', pointerDown);
    canvas.addEventListener('mousemove', pointerMove);
    window.addEventListener('mouseup', pointerUp);

    canvas.addEventListener('touchstart', pointerDown, { passive:false });
    canvas.addEventListener('touchmove', pointerMove, { passive:false });
    window.addEventListener('touchend', pointerUp, { passive:false });
  }

  // ðŸ†• UI actions
  penBtn.onclick = () => { mode = 'pen'; penBtn.disabled = true; eraserBtn.disabled = false; };
  eraserBtn.onclick = () => { mode = 'erase'; eraserBtn.disabled = true; penBtn.disabled = false; };
  clearBtn.onclick = () => {
    pushUndo();
    ctx.clearRect(0,0,canvas.width,canvas.height);
    refreshUndoRedoButtons();
  };
  undoBtn.onclick = () => {
    if (!undoStack.length) return;
    const state = undoStack.pop();
    try {
      redoStack.push(ctx.getImageData(0,0,canvas.width,canvas.height));
      ctx.putImageData(state, 0, 0);
    } catch {}
    refreshUndoRedoButtons();
  };
  redoBtn.onclick = () => {
    if (!redoStack.length) return;
    const state = redoStack.pop();
    try {
      undoStack.push(ctx.getImageData(0,0,canvas.width,canvas.height));
      ctx.putImageData(state, 0, 0);
    } catch {}
    refreshUndoRedoButtons();
  };
  saveBtn.onclick = () => {
    const link = document.createElement('a');
    link.download = `kono-draw-${new Date().toISOString().replace(/[:.]/g,'-')}.png`;
    link.href = canvas.toDataURL('image/png');
    link.click();
  };
  sizeEl.oninput = () => { sizeVal.textContent = sizeEl.value; };

  // ðŸ†• Keyboard shortcuts (optional on desktop)
  window.addEventListener('keydown', (e) => {
    const z = e.key.toLowerCase() === 'z';
    const y = e.key.toLowerCase() === 'y';
    if ((e.metaKey || e.ctrlKey) && z && !e.shiftKey) { undoBtn.click(); }
    else if ((e.metaKey || e.ctrlKey) && (e.shiftKey && z || y)) { redoBtn.click(); }
    else if (e.key.toLowerCase() === 'p') { penBtn.click(); }
    else if (e.key.toLowerCase() === 'e') { eraserBtn.click(); }
  });

  // ðŸ†• Initial UI state
  penBtn.disabled = true;
  refreshUndoRedoButtons();

  // ðŸ†• Optional: turn off pressure if you prefer constant width
  // pressureEnabled = false;
})();
</script>
</body>
</html>
