<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Kono Draw (Comfort Fix)</title>

<!-- ðŸ†• iPad-friendly display -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<style>
  :root { --ui:#f5f5f7; --line:#ddd; --ink:#111; }
  html, body { height:100%; margin:0; }
  /* ðŸ†• Prevent text selection while drawing */
  html, body, canvas, * {
    -webkit-user-select: none;
    user-select: none;
    -webkit-touch-callout: none;
  }
  body { background:#fff; font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif; overflow:hidden; } /* ðŸ†• stop page scrolling */

  .toolbar {
    position: fixed; inset: 0 0 auto 0;
    display:flex; gap:.5rem; align-items:center; padding:.5rem .75rem;
    background: var(--ui); border-bottom: 1px solid var(--line); z-index: 10;
  }
  .toolbar > * { height: 36px; }
  .btn {
    padding:.4rem .7rem; border:1px solid var(--line); background:#fff; border-radius:10px; cursor:pointer;
  }
  .btn[disabled] { opacity:.45; cursor:not-allowed; }
  .group { display:flex; gap:.5rem; align-items:center; }
  .spacer { flex:1; }
  input[type="range"] { width:140px; }
  label { font-size:.85rem; color:#333; }

  /* ðŸ†• Crucial: block browser gestures on the canvas */
  #canvas {
    position: fixed; top: 56px; left:0; right:0; bottom:0;
    display:block;
    touch-action: none;              /* no pan/zoom */
    -ms-touch-action: none;
  }
</style>
</head>
<body oncontextmenu="return false;"> <!-- ðŸ†• disable long-press context menu -->

  <div class="toolbar" id="toolbar">
    <div class="group">
      <button class="btn" id="penBtn" title="Pen (P)">Pen</button>
      <button class="btn" id="eraserBtn" title="Eraser (E)">Eraser</button>
      <button class="btn" id="clearBtn" title="Clear">Clear</button>
    </div>
    <div class="group">
      <label>Color</label>
      <input type="color" id="color" value="#111111">
    </div>
    <div class="group">
      <label>Brush</label>
      <input type="range" id="size" min="1" max="48" value="8">
      <span id="sizeVal" style="font-size:.85rem;color:#333;">8</span>
    </div>
    <div class="group">
      <button class="btn" id="undoBtn" title="Undo (âŒ˜/Ctrl+Z)">Undo</button>
      <button class="btn" id="redoBtn" title="Redo (âŒ˜/Ctrl+Shift+Z)">Redo</button>
    </div>
    <div class="spacer"></div>
    <div class="group">
      <!-- ðŸ†• Toggle: Pencil only -->
      <label><input type="checkbox" id="pencilOnly"> ðŸ†• Pencil only</label>
      <button class="btn" id="saveBtn" title="Save PNG">Save PNG</button>
    </div>
  </div>

  <canvas id="canvas"></canvas>

<script>
(() => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  const colorEl = document.getElementById('color');
  const sizeEl  = document.getElementById('size');
  const sizeVal = document.getElementById('sizeVal');
  const penBtn = document.getElementById('penBtn');
  const eraserBtn = document.getElementById('eraserBtn');
  const clearBtn = document.getElementById('clearBtn');
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');
  const saveBtn = document.getElementById('saveBtn');
  const pencilOnlyEl = document.getElementById('pencilOnly'); // ðŸ†• Pencil-only checkbox

  let isDrawing = false;
  let lastX = 0, lastY = 0;
  let mode = 'pen'; // 'pen' | 'erase'
  let pressureEnabled = true;

  // ðŸ†• Undo/Redo
  const UNDO_LIMIT = 30;
  const undoStack = [];
  const redoStack = [];
  function pushUndo() {
    try {
      if (undoStack.length >= UNDO_LIMIT) undoStack.shift();
      undoStack.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
      redoStack.length = 0;
      refreshUndoRedoButtons();
    } catch (e) {
      console.warn('Undo snapshot failed', e);
    }
  }
  function refreshUndoRedoButtons(){
    undoBtn.disabled = undoStack.length === 0;
    redoBtn.disabled = redoStack.length === 0;
  }

  // ðŸ†• High-DPI canvas sizing & preserve content on rotate/resize
  function resizeCanvas() {
    const toolbarH = document.getElementById('toolbar').offsetHeight || 56;
    const cssW = window.innerWidth;
    const cssH = Math.max(0, window.innerHeight - toolbarH);

    const ratio = Math.max(1, window.devicePixelRatio || 1);

    const oldW = canvas.width, oldH = canvas.height;
    const old = (oldW && oldH) ? ctx.getImageData(0, 0, oldW, oldH) : null;

    canvas.style.width = cssW + 'px';
    canvas.style.height = cssH + 'px';
    canvas.width = Math.floor(cssW * ratio);
    canvas.height = Math.floor(cssH * ratio);

    ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.imageSmoothingEnabled = true;

    if (old) {
      const off = document.createElement('canvas');
      off.width = old.width; off.height = old.height;
      off.getContext('2d').putImageData(old, 0, 0);
      ctx.save();
      ctx.setTransform(1,0,0,1,0,0);
      ctx.drawImage(off, 0, 0, old.width / ratio, old.height / ratio);
      ctx.restore();
    }
    refreshUndoRedoButtons();
  }
  window.addEventListener('resize', resizeCanvas, { passive: true });
  resizeCanvas();

  // ðŸ†• Prevent the page from scrolling while touching the canvas
  ['touchstart','touchmove','touchend','gesturestart'].forEach(type=>{
    canvas.addEventListener(type, (e)=> e.preventDefault(), { passive:false });
  });

  // Drawing helpers
  function getPoint(e){
    const rect = canvas.getBoundingClientRect();
    let x, y;
    if (e.touches && e.touches[0]) {
      x = e.touches[0].clientX - rect.left;
      y = e.touches[0].clientY - rect.top;
    } else {
      x = e.clientX - rect.left;
      y = e.clientY - rect.top;
    }
    return { x, y };
  }

  function pointerDown(e){
    // ðŸ†• If Pencil-only is ON, ignore finger/mouse
    if (pencilOnlyEl.checked && e.pointerType && e.pointerType !== 'pen') return;

    e.preventDefault();
    pushUndo();
    isDrawing = true;
    const { x, y } = getPoint(e);
    lastX = x; lastY = y;
    drawLine(x, y, x, y, e);
  }

  function pointerMove(e){
    if (!isDrawing) return;
    if (pencilOnlyEl.checked && e.pointerType && e.pointerType !== 'pen') return;

    e.preventDefault();
    const { x, y } = getPoint(e);
    drawLine(lastX, lastY, x, y, e);
    lastX = x; lastY = y;
  }

  function pointerUp(e){
    if (!isDrawing) return;
    e.preventDefault();
    isDrawing = false;
  }

  function drawLine(x1, y1, x2, y2, e){
    const baseSize = Number(sizeEl.value);
    const p = (e.pressure && pressureEnabled) ? Math.max(0.1, e.pressure) : 1;
    const width = baseSize * p;

    ctx.save();
    ctx.globalCompositeOperation = mode === 'erase' ? 'destination-out' : 'source-over';
    if (mode === 'pen') ctx.strokeStyle = colorEl.value;

    ctx.lineWidth = width;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();
  }

  // ðŸ†• Prefer Pointer Events (mouse/touch/Pencil)
  if ('onpointerdown' in window){
    canvas.addEventListener('pointerdown', pointerDown, { passive:false });
    canvas.addEventListener('pointermove', pointerMove, { passive:false });
    window.addEventListener('pointerup', pointerUp, { passive:false });
    canvas.style.touchAction = 'none';
  } else {
    // Fallback
    canvas.addEventListener('mousedown', pointerDown);
    canvas.addEventListener('mousemove', pointerMove);
    window.addEventListener('mouseup', pointerUp);
    canvas.addEventListener('touchstart', pointerDown, { passive:false });
    canvas.addEventListener('touchmove', pointerMove, { passive:false });
    window.addEventListener('touchend', pointerUp, { passive:false });
  }

  // UI actions
  penBtn.onclick = () => { mode = 'pen'; penBtn.disabled = true; eraserBtn.disabled = false; };
  eraserBtn.onclick = () => { mode = 'erase'; eraserBtn.disabled = true; penBtn.disabled = false; };
  clearBtn.onclick = () => { pushUndo(); ctx.clearRect(0,0,canvas.width,canvas.height); refreshUndoRedoButtons(); };
  undoBtn.onclick = () => {
    if (!undoStack.length) return;
    const state = undoStack.pop();
    try { redoStack.push(ctx.getImageData(0,0,canvas.width,canvas.height)); ctx.putImageData(state, 0, 0); } catch {}
    refreshUndoRedoButtons();
  };
  redoBtn.onclick = () => {
    if (!redoStack.length) return;
    const state = redoStack.pop();
    try { undoStack.push(ctx.getImageData(0,0,canvas.width,canvas.height)); ctx.putImageData(state, 0, 0); } catch {}
    refreshUndoRedoButtons();
  };
  saveBtn.onclick = () => {
    const link = document.createElement('a');
    link.download = `kono-draw-${new Date().toISOString().replace(/[:.]/g,'-')}.png`;
    link.href = canvas.toDataURL('image/png');
    link.click();
  };
  sizeEl.oninput = () => { sizeVal.textContent = sizeEl.value; };

  // Shortcuts (desktop)
  window.addEventListener('keydown', (e) => {
    const k = e.key.toLowerCase();
    if ((e.metaKey || e.ctrlKey) && k === 'z' && !e.shiftKey) { undoBtn.click(); }
    else if ((e.metaKey || e.ctrlKey) && (e.shiftKey && k === 'z' || k === 'y')) { redoBtn.click(); }
    else if (k === 'p') { penBtn.click(); }
    else if (k === 'e') { eraserBtn.click(); }
  });

  // Initial state
  penBtn.disabled = true;
  refreshUndoRedoButtons();
})();
</script>
</body>
</html>
